<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Argocd on Jesse Builds Software</title>
    <link>http://localhost:1313/tags/argocd/</link>
    <description>Recent content in Argocd on Jesse Builds Software</description>
    <generator>Hugo</generator>
    <language>en-CA</language>
    <lastBuildDate>Mon, 26 Jun 2023 10:55:24 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/argocd/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Automating Non-Non-Downtime Upgrades in Kubernetes with ArgoCD</title>
      <link>http://localhost:1313/posts/2023-06-26-automating-non-non-downtime-upgrades-in-kubernetes-with-argocd/</link>
      <pubDate>Mon, 26 Jun 2023 10:55:24 +0000</pubDate>
      <guid>http://localhost:1313/posts/2023-06-26-automating-non-non-downtime-upgrades-in-kubernetes-with-argocd/</guid>
      <description>I recently worked on a project to move a complicated legacy application onto Kubernetes. It was quite an undertaking, but in the end we were successful. One of the biggest challenges was figuring out how to automate our legacy deployment process, one where the whole application has to be stopped completely for schema upgrades to run.&#xA;The normal &amp;ldquo;Kubernetes way&amp;rdquo; to upgrade an application is by changing the Deployment resource. With its default RollingUpdate strategy it will delete a pod with the old definition, start a pod with the new definition, wait for it to be healthy, then repeat continuously until the change is fully applied.</description>
    </item>
  </channel>
</rss>
