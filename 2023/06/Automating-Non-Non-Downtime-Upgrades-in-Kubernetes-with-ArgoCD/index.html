<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Automating Non-Non-Downtime Upgrades in Kubernetes with ArgoCD | Jesse Builds Software</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script src="https://www.googletagmanager.com/gtag/js?id=UA-17968343-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-17968343-1');
</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "19dbe594294e444cab1e984fe13d4e7a"}'></script><meta name="generator" content="Hexo 7.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Automating Non-Non-Downtime Upgrades in Kubernetes with ArgoCD</h1><a id="logo" href="/.">Jesse Builds Software</a><p class="description">Jesse's thoughts on building quality software.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Automating Non-Non-Downtime Upgrades in Kubernetes with ArgoCD</h1><div class="post-meta">2023-06-26</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#What-is-ArgoCD-and-What-Are-Sync-Phases-and-Waves"><span class="toc-number">1.</span> <span class="toc-text">What is ArgoCD and What Are Sync Phases and Waves?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-We-Automated-our-Deployment-Process"><span class="toc-number">2.</span> <span class="toc-text">How We Automated our Deployment Process</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Branching-Strategy"><span class="toc-number">3.</span> <span class="toc-text">Branching Strategy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Good-Our-Upgrade-Process"><span class="toc-number">4.</span> <span class="toc-text">The Good: Our Upgrade Process</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Bad-Scaling-Pods-Without-Downtime"><span class="toc-number">5.</span> <span class="toc-text">The Bad: Scaling Pods Without Downtime</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Ugly-Automatic-Synchronization"><span class="toc-number">6.</span> <span class="toc-text">The Ugly: Automatic Synchronization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">7.</span> <span class="toc-text">Conclusion</span></a></li></ol></div></div><div class="post-content"><p>I recently worked on a project to move a complicated legacy application onto Kubernetes. It was quite an undertaking, but in the end we were successful. One of the biggest challenges was figuring out how to automate our legacy deployment process, one where the whole application has to be stopped completely for schema upgrades to run.</p>
<p>The normal “Kubernetes way” to upgrade an application is by changing the <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment resource</a>. With its default <code>RollingUpdate</code> strategy it will delete a pod with the old definition, start a pod with the new definition, wait for it to be healthy, then repeat continuously until the change is fully applied.</p>
<p>This process wouldn’t work for us, and it was not obvious how we could automate one that did. Our application is tied to its schema version; new versions of the app won’t run on the old schema, old versions of the app can’t run on the new schema, and the schema migrator won’t start if it detects any running applications. We would have preferred to use a rolling update without downtime, but it wasn’t possible to make our application support this in our timelines. I expect it will eventually be implemented, but it will require several changes and a significant testing effort.</p>
<p>The process we wanted to automate was:</p>
<ol>
<li>Shut down the old version of the application</li>
<li>Run the schema migrator</li>
<li>Start the new version of the application</li>
</ol>
<p>Or putting it into Kubernetes terms:</p>
<ol>
<li>Delete all the pods</li>
<li>Run the schema migrator job</li>
<li>Create new pods (with new image tag)</li>
</ol>
<p>We tried a few different approaches, but the solution we ultimately chose was using <a target="_blank" rel="noopener" href="https://argoproj.github.io/cd/">ArgoCD</a> with its <a target="_blank" rel="noopener" href="https://argo-cd.readthedocs.io/en/stable/user-guide/sync-waves/">sync phases and waves feature</a>. There were a few unexpected challenges, but we were still happy with the results.</p>
<h2 id="What-is-ArgoCD-and-What-Are-Sync-Phases-and-Waves"><a href="#What-is-ArgoCD-and-What-Are-Sync-Phases-and-Waves" class="headerlink" title="What is ArgoCD and What Are Sync Phases and Waves?"></a>What is ArgoCD and What Are Sync Phases and Waves?</h2><p><a target="_blank" rel="noopener" href="https://argoproj.github.io/cd/">ArgoCD</a> is a powerful open source tool that lets you deploy Helm charts to a Kubernetes cluster. The charts and their settings are pulled from a configurable source, in our case GitHub. This allowed us to store all our Kubernetes configuration as code. We wanted better visibility and consistency in our infrastructure and this tool makes that possible. Being able to add “GitOps” is an added bonus.</p>
<p>ArgoCD is based on a custom resource called an <a target="_blank" rel="noopener" href="https://argo-cd.readthedocs.io/en/stable/operator-manual/declarative-setup/#applications">Application</a>. An application represents a single installation of a Helm chart. Its resource includes a source (where to retrieve the chart), a destination (where to install the chart), and any parameters to apply to the chart. You can automate more complicated scenarios with charts containing Applications, resulting in Applications containing Applications. You can also use the <a target="_blank" rel="noopener" href="https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/">ApplicationSet</a> resource to generate multiple Application objects. We combine all of these to push out a lot of similar but not exactly the same applications in several environments.</p>
<p>ArgoCD periodically compares the source (code) and destination (cluster state). If there are any differences, the application gets marked as out of sync. ArgoCD can synchronize all the changes in an application automatically or with the press of a button. It also has a nice user interface that shows all the applications, their state, and some other useful information.</p>
<p>If your application can be deployed all at once as a simple Helm chart, ArgoCD can easily do this. For a more complicated deployment process like ours, we used the sync phases and waves feature; we added special annotations in a few our resource definitions to control the order ArgoCD applies their changes. It looks like this:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">argocd.argoproj.io/hook:</span> <span class="string">PreSync</span></span><br><span class="line">    <span class="attr">argocd.argoproj.io/sync-wave:</span> <span class="string">&quot;5&quot;</span></span><br></pre></td></tr></table></figure>


<h2 id="How-We-Automated-our-Deployment-Process"><a href="#How-We-Automated-our-Deployment-Process" class="headerlink" title="How We Automated our Deployment Process"></a>How We Automated our Deployment Process</h2><p>Our process uses these steps:</p>
<ol>
<li><code>PreSync</code> &#x2F; <code>-1</code> - Create necessary secrets, service accounts, etc.</li>
<li><code>PreSync</code> &#x2F; <code>10</code> - Create job: run a script that sets the replica count to 0</li>
<li><code>PreSync</code> &#x2F; <code>20</code> - Create job: run the schema migrator docker image</li>
<li><code>Sync</code> (default) - Create the deployment, services, and everything else</li>
</ol>
<p>The <code>PreSync</code> &#x2F; <code>10</code> step ensures the application is stopped before continuing. It checks that the deployment exists so it won’t fail on the very first run, then it sets the replica count to 0. The pods get deleted pretty quickly after this change is applied.</p>
<p>The schema migrator job runs next. It can upgrade the schema of an existing database or create a new one if one doesn’t already exists. Once it completes, all the rest of the resources are created in the <code>Sync</code> step. The deployment resource sets the new application version and restores the replica count. Pods start getting created, and pretty soon we have a fully working application.</p>
<p>If the schema migrator job fails, Kubernetes will execute any retries as per the job definition. If the job can’t complete, the synchronization cycle stops and gets marked as failed in ArgoCD. A human can then make any necessary changes and trigger another synchronization cycle.</p>
<p>We ran this process hundreds of times in our development environment and several more in our production environments. The ArgoCD part of it always worked correctly. Since some of our applications had an installation per tenant, we also ran several in parallel with no issues. We did have a few deployments fail, but they were all caused by infrastructure issues or application bugs. That won’t be different from any other Kubernetes system.</p>
<h2 id="Branching-Strategy"><a href="#Branching-Strategy" class="headerlink" title="Branching Strategy"></a>Branching Strategy</h2><p>The GitOps approach to managing our environments brought some significant benefits, but it also made it more challenging to test changes to our charts. For example, some application changes would require add or dropping startup parameters in the pod definition. We had to be especially careful that it wouldn’t break an environment if the new chart was applied before the application version was updated. It was possible to deal with simple changes like this using conditional blocks in the Helm templates, but it got a lot more messy when we were updating community charts for our logging or monitoring infrastructure, or changing the shared ingress definitions.</p>
<p>To ensure we didn’t have any accidents we moved to a branching strategy. We now use three branches:</p>
<ul>
<li>develop - for our development environment. This is where most of our chart changes occur. It’s also where we test daily builds of our applications</li>
<li>staging - for our staging environment. We use this to test new charts and applications before a production release</li>
<li>production - for all of our production environments</li>
</ul>
<p>Changes to the charts get tested in the development environment. They then get merged to the staging branch just before a major release. As part of the production release cycle we merge the same changes from the staging branch to the production branch, making sure that only tested changes get deployed.</p>
<p>To ensure there is no configuration drift, we also occasionally merge changes from the staging and production branches back to the development branch.</p>
<p>We did find branching a bit difficult to use, especially for parts of our team that had less experience with Git. Even with this difficulty, we found the added safety worthwhile.</p>
<h2 id="The-Good-Our-Upgrade-Process"><a href="#The-Good-Our-Upgrade-Process" class="headerlink" title="The Good: Our Upgrade Process"></a>The Good: Our Upgrade Process</h2><p>Our upgrade run list was beautifully simple:</p>
<ol>
<li>Make sure the environment is healthy and all the Application resources are in a healthy state</li>
<li>Merge any changes from the previous branch to the target branch (ex: develop to staging, or staging to production).</li>
<li>For each installation, modify the version (docker image tag) in the appropriate configuration yaml files and merge those.</li>
<li>Find the applications marked as out of sync in ArgoCD and trigger synchronization cycles. Wait for them to finish.</li>
</ol>
<p>Once we started the synchronization cycle, ArgoCD would start applying the changes. A few minutes later the new version would start up and the web services would start responding to requests again.</p>
<h2 id="The-Bad-Scaling-Pods-Without-Downtime"><a href="#The-Bad-Scaling-Pods-Without-Downtime" class="headerlink" title="The Bad: Scaling Pods Without Downtime"></a>The Bad: Scaling Pods Without Downtime</h2><p>The biggest drawback of this approach was the inability to make minor configuration tweaks to our production system through the code. ArgoCD uses a synchronization cycle to apply changes from the source. This was great when we were changing the version of the application and the schema migrator needed to run, but it wasn’t so great when we needed to add a little memory or increase the replica count to keep everything working smoothly.</p>
<p>In these cases we had to make changes to the Kubernetes resources directly, bypassing ArgoCD. This meant the Application resources would be marked as out of sync until we made the same changes in the code. If we forgot this step, the changes would get stomped during the next synchronization cycle.</p>
<p>ArgoCD has a feature to ignore certain state differences in a resource. This is great when you’re using autoscaling or other Kubernetes automation features. We couldn’t use it though because it also sometimes prevented ArgoCD from applying the changes to raise the replica count from 0 in the <code>Sync</code> phase.</p>
<p>This is only an issue when deploying applications that need downtime while the chart is being applied. Many applications that are designed to run it Kubernetes will keep working throughout this process, and ArgoCD can handle this just fine.</p>
<h2 id="The-Ugly-Automatic-Synchronization"><a href="#The-Ugly-Automatic-Synchronization" class="headerlink" title="The Ugly: Automatic Synchronization"></a>The Ugly: Automatic Synchronization</h2><p>ArgoCD is capable of triggering synchronization cycles automatically when it detects changes. This is helpful if you want to ensure your cluster’s state is always identical to your committed code, which is the ultimate in a GitOps workflow. The drawback is that it also means a synchronization cycle can be triggered whenever changes are detected. Since our process involves downtime, we didn’t want this to happen unintentionally in our production environments.</p>
<p>The other problem we ran into with automatic synchronization was that it made it harder to test minor configuration changes in our development environment. If we added or removed a bit of memory to measure the impact, ArgoCD would quickly reset it back. We could add parameters to allow these things to be configured, but that increased the complexity of the charts and made them harder to read. It also meant we had to remember te remove the same changes again later.</p>
<p>The setting for automatic synchronization is specified on a per-application basis via the resource definition, so you can make this behavior optional for some of your applications. We decided to use manual synchronization in our staging and production environments for everything but the top-level charts. This allowed us to control when changes were applied.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Using ArgoCD for automating the more complicated upgrade process worked well for us, even with its challenges. I would recommend this solution to others.</p>
<p>Another strong reason to use ArgoCD is that it is an excellent tool to use even if you don’t need to control the synchronization process. It was a great platform for us to deploy newer Kubernetes-native applications, and it was convenient to use the same tool for everything. It also left us in a position where we could iterate gradually to a simpler deployment process with our legacy applications.</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/argocd/" rel="tag">argocd</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/devops/" rel="tag">devops</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kubernetes/" rel="tag">kubernetes</a></li></ul></div><div class="post-nav"><a class="pre" href="/2023/07/Case-of-the-Appearing-Users/">Case of the Appearing Users</a><a class="next" href="/2023/06/Importance-of-Alignment/">Importance of Alignment</a></div><script src="https://utteranc.es/client.js" repo="jessemcdowell/jessemcdowell-blog-comments" issue-term="title" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://jessemcdowell.ca"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://pragmaticpotato.com/" title="Pragmatic Potato Software" target="_blank">Pragmatic Potato Software</a><ul></ul><a href="/resources/" title="Resources" target="_blank">Resources</a><ul></ul><a href="/mysterysolver/" title="Mystery Solver" target="_blank">Mystery Solver</a><ul></ul><a href="/licence/" title="Licence" target="_blank">Licence</a></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/blogging/" style="font-size: 15px;">blogging</a> <a href="/tags/design/" style="font-size: 15px;">design</a> <a href="/tags/sql/" style="font-size: 15px;">sql</a> <a href="/tags/devops/" style="font-size: 15px;">devops</a> <a href="/tags/gadgets/" style="font-size: 15px;">gadgets</a> <a href="/tags/open-source/" style="font-size: 15px;">open source</a> <a href="/tags/ioc/" style="font-size: 15px;">ioc</a> <a href="/tags/unit-testing/" style="font-size: 15px;">unit testing</a> <a href="/tags/database/" style="font-size: 15px;">database</a> <a href="/tags/entity-framework/" style="font-size: 15px;">entity framework</a> <a href="/tags/net/" style="font-size: 15px;">.net</a> <a href="/tags/debugging/" style="font-size: 15px;">debugging</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/people-management/" style="font-size: 15px;">people management</a> <a href="/tags/food/" style="font-size: 15px;">food</a> <a href="/tags/leadership/" style="font-size: 15px;">leadership</a> <a href="/tags/c/" style="font-size: 15px;">c#</a> <a href="/tags/interviewing/" style="font-size: 15px;">interviewing</a> <a href="/tags/career/" style="font-size: 15px;">career</a> <a href="/tags/consulting/" style="font-size: 15px;">consulting</a> <a href="/tags/project-management/" style="font-size: 15px;">project management</a> <a href="/tags/performance/" style="font-size: 15px;">performance</a> <a href="/tags/learning/" style="font-size: 15px;">learning</a> <a href="/tags/practices/" style="font-size: 15px;">practices</a> <a href="/tags/quality/" style="font-size: 15px;">quality</a> <a href="/tags/angular/" style="font-size: 15px;">angular</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/tea/" style="font-size: 15px;">tea</a> <a href="/tags/recipes/" style="font-size: 15px;">recipes</a> <a href="/tags/bugs/" style="font-size: 15px;">bugs</a> <a href="/tags/war-stories/" style="font-size: 15px;">war stories</a> <a href="/tags/video-games/" style="font-size: 15px;">video games</a> <a href="/tags/community/" style="font-size: 15px;">community</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/argocd/" style="font-size: 15px;">argocd</a> <a href="/tags/architecture/" style="font-size: 15px;">architecture</a> <a href="/tags/resources/" style="font-size: 15px;">resources</a> <a href="/tags/reviews/" style="font-size: 15px;">reviews</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/howto/" style="font-size: 15px;">howto</a> <a href="/tags/pragmatic-potato/" style="font-size: 15px;">pragmatic potato</a> <a href="/tags/code-reviews/" style="font-size: 15px;">code reviews</a> <a href="/tags/household-organization/" style="font-size: 15px;">household organization</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/typescript/" style="font-size: 15px;">typescript</a></div></div><div class="widget"><div class="widget-title">Subscribe</div><ul></ul><i class="fa fa-rss"></i><a href="/atom.xml" title="Atom" target="_blank"> Atom</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Jesse Builds Software.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>